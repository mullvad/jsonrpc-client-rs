// Copyright 2017 Amagicom AB.
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.


//! A crate for generating transport agnostic, auto serializing, strongly typed JSON-RPC 2.0
//! clients.
//!
//! This crate mainly provides a macro, `jsonrpc_client`. The macro generates structs that can be
//! used for calling JSON-RPC 2.0 APIs. The macro lets you list methods on the struct with
//! arguments and a return type. The macro then generates a struct which will automatically
//! serialize the arguments, send the request and deserialize the response into the target type.
//!
//! # Transports
//!
//! The `jsonrpc-client-core` crate itself and the structs generated by the `jsonrpc_client` macro
//! are transport agnostic. They can use any type implementing the `Transport` trait.
//!
//! The main (and so far only) transport implementation is the Hyper based HTTP implementation
//! in the `jsonrpc-client-http` crate.
//!
//! # Example
//!
//! ```rust,no_run
//! #[macro_use] extern crate jsonrpc_client_core;
//! extern crate jsonrpc_client_http;
//!
//! use jsonrpc_client_http::HttpTransport;
//!
//! jsonrpc_client!(pub struct FizzBuzzClient {
//!     /// Returns the fizz-buzz string for the given number.
//!     pub fn fizz_buzz(&mut self, number: u64) -> RpcRequest<String>;
//! });
//!
//! fn main() {
//!     let transport = HttpTransport::builder().build().unwrap();
//!     let transport_handle = transport.handle("https://api.fizzbuzzexample.org/rpc/").unwrap();
//!     let mut client = FizzBuzzClient::new(transport_handle);
//!     let result1 = client.fizz_buzz(3).call().unwrap();
//!     let result2 = client.fizz_buzz(4).call().unwrap();
//!     let result3 = client.fizz_buzz(5).call().unwrap();
//!
//!     // Should print "fizz 4 buzz" if the server implemented the service correctly
//!     println!("{} {} {}", result1, result2, result3);
//! }
//! ```
//!

#![deny(missing_docs)]

#[macro_use]
extern crate error_chain;
extern crate futures;
extern crate jsonrpc_core;
#[macro_use]
extern crate log;
extern crate serde;
#[cfg_attr(test, macro_use)]
extern crate serde_json;

use futures::future::{BoxFuture, Future};
use serde_json::Value as JsonValue;

/// Contains the main macro of this crate, `jsonrpc_client`.
#[macro_use]
mod macros;

/// Module for functions parsing the response to a RPC method call.
mod response;

/// Module containing an example client. To show in the docs what a generated struct look like.
pub mod example;

error_chain! {
    errors {
        /// Error in the underlying transport layer.
        TransportError {
            description("Unable to send the JSON-RPC 2.0 request")
        }
        /// Error while serializing method parameters.
        SerializeError {
            description("Unable to serialize the method parameters")
        }
        /// Error while deserializing or parsing the response data.
        ResponseError(msg: &'static str) {
            description("Unable to deserialize the response into the desired type")
            display("Unable to deserialize the response: {}", msg)
        }
        /// The request was replied to, but with a JSON-RPC 2.0 error.
        JsonRpcError(error: jsonrpc_core::types::error::Error) {
            description("Method call returned JSON-RPC 2.0 error")
            display("JSON-RPC 2.0 Error: {} ({})", error.code.description(), error.message)
        }
    }
}

/// A lazy RPC call `Future`. The actual call has not been sent when an instance of this type
/// is returned from a client generated by the macro in this crate. This is a `Future` that, when
/// executed, performs the RPC call.
pub struct RpcRequest<T>(BoxFuture<T, Error>);

impl<T> RpcRequest<T> {
    /// Consume this RPC request and run it synchronously. This blocks until the RPC call is done,
    /// then the result of the call is returned.
    pub fn call(self) -> Result<T> {
        self.0.wait()
    }
}

impl<T> Future for RpcRequest<T> {
    type Item = T;
    type Error = Error;

    fn poll(&mut self) -> futures::Poll<Self::Item, Self::Error> {
        self.0.poll()
    }
}

/// Trait for types acting as a transport layer for the JSON-RPC 2.0 clients generated by the
/// `jsonrpc_client` macro.
pub trait Transport<E: ::std::error::Error + Send + 'static>
    : Clone + Send + 'static {
    /// Returns an id that has not yet been used on this transport. Used by the RPC clients
    /// to fill in the "id" field of a request.
    fn get_next_id(&mut self) -> u64;

    /// Sends the given data over the transport and returns a future that will complete with the
    /// response to the request, or the transport specific error if something went wrong.
    fn send(&self, json_data: Vec<u8>) -> BoxFuture<Vec<u8>, E>;
}


/// Prepares a lazy `RpcRequest` with a given transport, method and parameters.
/// The call is not sent to the transport until the returned `RpcRequest` is actually executed,
/// either as a `Future` or by calling `RpcRequest::call()`.
///
/// # Not intended for direct use
/// This is being called from the client structs generated by the `jsonrpc_client` macro. This
/// function is not intended to be used directly, only the generated structs should call this.
pub fn call_method<E, T, P, R>(mut transport: T, method: &str, params: P) -> RpcRequest<R>
where
    E: ::std::error::Error + Send + 'static,
    T: Transport<E>,
    P: serde::Serialize,
    for<'de> R: serde::Deserialize<'de> + Send + 'static,
{
    let id = transport.get_next_id();
    trace!("Serializing call to method \"{}\" with id {}", method, id);
    let request = serialize_request(id, method, params).chain_err(|| ErrorKind::SerializeError);
    let method_copy1 = method.to_owned();
    let method_copy2 = method.to_owned();

    RpcRequest(
        futures::future::result(request)
            .and_then(move |request_raw| {
                trace!(
                    "Sending call to method \"{}\" with id {} to transport",
                    method_copy1,
                    id
                );
                transport
                    .send(request_raw)
                    .map_err(|e| Error::with_chain(e, ErrorKind::TransportError))
            })
            .and_then(move |response_raw: Vec<u8>| {
                trace!(
                    "Deserializing response to method \"{}\" with id {}",
                    method_copy2,
                    id
                );
                response::parse::<R>(&response_raw, id)
            })
            .boxed(),
    )
}


/// Creates a JSON-RPC 2.0 request to the given method with the given parameters.
fn serialize_request<P>(
    id: u64,
    method: &str,
    params: P,
) -> ::std::result::Result<Vec<u8>, serde_json::error::Error>
where
    P: serde::Serialize,
{
    let mut request_map = serde_json::Map::new();
    request_map.insert(String::from("jsonrpc"), JsonValue::from("2.0"));
    request_map.insert(String::from("id"), JsonValue::from(id));
    request_map.insert(String::from("method"), JsonValue::from(method));
    request_map.insert(String::from("params"), serde_json::to_value(params)?);

    serde_json::to_vec(&JsonValue::Object(request_map))
}



#[cfg(test)]
mod tests {
    use super::*;
    use std::io;

    /// A test transport that just echoes back a response containing the entire request as the
    /// result.
    #[derive(Clone)]
    struct EchoTransport;

    impl Transport<io::Error> for EchoTransport {
        fn get_next_id(&mut self) -> u64 {
            1
        }

        fn send(&self, json_data: Vec<u8>) -> BoxFuture<Vec<u8>, io::Error> {
            let json = json!({
                "jsonrpc": "2.0",
                "id": 1,
                "result": serde_json::from_slice::<JsonValue>(&json_data).unwrap(),
            });
            futures::future::ok(serde_json::to_vec(&json).unwrap()).boxed()
        }
    }

    /// A transport that always returns an "Invalid request" error
    #[derive(Clone)]
    struct ErrorTransport;

    impl Transport<io::Error> for ErrorTransport {
        fn get_next_id(&mut self) -> u64 {
            1
        }

        fn send(&self, _json_data: Vec<u8>) -> BoxFuture<Vec<u8>, io::Error> {
            let json = json!({
                "jsonrpc": "2.0",
                "id": 1,
                "error": {
                    "code": -32600,
                    "message": "This was an invalid request",
                    "data": [1, 2, 3],
                }
            });
            futures::future::ok(serde_json::to_vec(&json).unwrap()).boxed()
        }
    }

    jsonrpc_client!(pub struct TestRpcClient {
        pub fn ping(&mut self, arg0: &str) -> RpcRequest<JsonValue>;
    });

    #[test]
    fn echo() {
        let mut client = TestRpcClient::new(EchoTransport);
        let result = client.ping("Hello").call().unwrap();
        if let JsonValue::Object(map) = result {
            assert_eq!(Some(&JsonValue::from("2.0")), map.get("jsonrpc"));
            assert_eq!(Some(&JsonValue::from(1)), map.get("id"));
            assert_eq!(Some(&JsonValue::from("ping")), map.get("method"));
            assert_eq!(Some(&JsonValue::from(vec!["Hello"])), map.get("params"));
            assert_eq!(4, map.len());
        } else {
            panic!("Invalid response type: {:?}", result);
        }
    }

    #[test]
    fn error() {
        let mut client = TestRpcClient::new(ErrorTransport);
        let error = client.ping("").call().unwrap_err();
        if let &ErrorKind::JsonRpcError(ref json_error) = error.kind() {
            use jsonrpc_core::types::error::ErrorCode;
            assert_eq!(ErrorCode::InvalidRequest, json_error.code);
            assert_eq!("This was an invalid request", json_error.message);
            assert_eq!(Some(json!{[1, 2, 3]}), json_error.data);
        } else {
            panic!("Wrong error kind");
        }
    }
}
